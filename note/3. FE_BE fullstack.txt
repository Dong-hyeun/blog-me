코드 참조: https://github.com/safak/youtube/tree/mern-blog-app

 - 프로젝트명: 

💡 UI, API까지 완료했고 마지막으로 설계한 API로 
   블러그를 완성해본다. 

💡 서버측에서 받아온 데이터로 화면에 랜더링해보자! 

💡 세팅 및 Scripts는 John Ahn님 강좌로 수강했던 내용 적용! 

(진행 목록)
01) 프로젝트 소개(Introduction)

(기술)
 - React, Axios, Express

(만들어볼 기능)
 ◎ 인증 기능(로그인, 회원가입, 로그아웃)
 ◎ Context api, 로컬스토리지로 (로그인, 로그아웃 구현을 위한) 
   유저 상태 관리
 ◎ User Profile (유저 관리 페이지)
  - 유저 프로필 페이지 구현 (프로필 사진 포함) 
  - 유저 정보 수정 및 삭제 기능  

 ◎ Post CRUD 기능 
  - PostId로 Post 상세페이지 및 Post 목록 페이지 
  - Post 작성 페이지 및 수정, 삭제 기능 

 ◎ Categorie 추가 및 조회(목록)
   

02) 리액트에서 백엔드로 데이터 Fetching (React.js how to fetch data from backend)
 - axios 설치
  → 데이터를 통신하기 위한(ajax) 라이브러리인 axios 설치  
  ◎ npm i axios 또는 yarn add axios

 - useEffect 내부에 비동기 함수 정의
  → 첫 랜더링시 (또는 게시글이 변경될 때마다), 서버측에서 
    get 요청으로 데이터을 가져오려면 useEffect 을 사용한다. 
  → useEffect 내에서 axios를 바로 사용할 수는 없고 
    비동기 함수를 정의해서 사용한다.
 -  CORS 이슈: proxy 로 해결
  → 전에 만든 api과 통신하기전에 CORS 이슈를 해결해줘야한다. 
    이 강의에서는 package.json에 proxy를 설정해주는 방법으로
    해결했다.
   ● 보통 cors 라이브러리를 사용해서 해결한다. 

 - axios를 사용해서 요청하기 
    const fetchPosts = async () => {
        const res = await axios.get('/posts');
        console.log(res);
    };
    useEffect(() => {
      fetchPosts();
    }, []);
  → 서버측('/post')에 요청하게되면 요청에 따른 응답 결과를 
    프론트쪽에 전달해준다. 그 결과값이 res라는 변수에 담긴다.
  
  → 응답을 받기 위해서는 일단 서버도 같이 실행해준다.
    ◎ 콘솔창을 보면 객체 형태로 데이터가 전달된 것을 
      확인할 수 있다.

03) Post 목록 페이지(Displaying all posts on the homepage)
 - 서버에서 전달 받은 post 데이터를 posts 컴포넌트에 
   랜더링하기 
 - 배열 내장 메서드인 map을 사용해서 포스트 목록들을 랜더링하기 
 -  post 컴포넌트에 필요한 데이터를 props로 전달해준다.  

04) React router dom을 사용한 동적 link(React router dom using dynamic link)
 - 전달받은 props로 포스트 제목, 날짜, 내용 등의 포스트 상세 페이지를 
   완성한다. 

 - post 컴포넌트에 Link 추가해서 포스트 목록의 제목을 클릭하면 
   해당 포스트 상세 페이지를 가도록 구현해본다. 

 - useLocation 함수로 pathname을 알아낼 수 있다. 
   이걸로 postId 값을 추출한다. 
  ◎ const { pathname } = useLocation();
  ◎ const postId = pathname.split('/')[2];
  → 이것을 하는 이유가 포스팅 상세 페이지에 관해 서버측에 
    요청하기 위해서다. 
    즉, /post/:id 형태로 요청하기 위함 

05) Axios를 사용해서 Post 상세페이지 Fetching(Fetching single post using Axios)
  - useEffect 함수를 사용해서 axios를 요청하기
   → post 목록을 불러올 때는 함수로 따로 빼서 했지만 
     이번에는 postId가 변경(다른 상세 포스트를 클릭할 때)할 
     때마다 useEffect 함수가 실행되어 fetching 하도록 
     처리한다. 

  - 서버에서 전달 받은 post 데이터로 포스트 상세 페이지를 
    구현하기 
    → 이건 포스트 목록 페이지 구현하는 방법과 동일하다. 
      (코드 확인) 

06) 모든 Categories Fetching(Fetching all categories)
  - 서버측에서 받은 Categories 데이터로 sidebar의
    카테고리 메뉴 구현하기 
  ◎ {categories.map(({ name }) => (
      <li className="sidebarListItem">
        <Link to={`/?categories=${name}`} className="link">
          {name}
        </Link>
      </li>
    ))}

07) Axios로 쿼리 사용하는 법(How to use query in Axios)
  - 로그인했을 때 해당 유저의 게시글 가져오기
   → 작성자를 클릭했을 때 작성자의 해당 게시글을 가져온다. 
   → 만약 /?user=mike" 이런 형태로 요청하게 되면 
     mike 유저의 게시글을 가져온다.
    ◎ /?user=${post && post.username}

08) 회원가입 구현(React Node.js Register System)
  - 회원가입 폼 구현하기
   → username, email, password 상태들을 선언한다. 
   → 회원가입 api로 폼데이터를 전송하고 응답된 결과값을 
     유저 상태 유지를 처리하기 위해 context api이나 
     쿠키 및 로컬스토리지에 담아서 관리한다. 
    
    💡사실 ajax 를 통해 데이터를 전송하는 방법은 
      거의 비슷하다.  

   → 강의에서는 에러 발생할 시, status code를 500으로 처리했지만 
     409으로 처리하는 것이 좋다고 한다. 
     ● 403 코드는 클라이언트가 권한이 없기 때문에 작업을 진행할 수 
       없는 경우의 에러코드 (인증 여부)
      ex) 인증(로그인)되지 않은 유저가 인증이 필요한 페이지에 
          접근할 때 403 에러를 반환할 수 있다. 

     ● 409 코드는 클라이언트의 요청이 서버의 상태와 충돌이 발생한 경우의 
       에러코드 (인증 여부)
      ex) 
       ◎ 이미 가입한 유저가 동일한 id로 회원가입할 때 409 에러를 
         반환할 수 있다. 

       ◎ 사용자의 게시물이 존재하는 경우 사용자를 삭제할 수 없다는 
         정책이 있는 경우 409 에러를 반환할 수 있다. 

       
09) Context API를 사용하는 이유(Why we are using Context API)
  - 유저 상태를 context api나 redux 또는 쿠키, 로컬스토리지등에 
    저장해서 관리할 수 있다. 
    (여기서는 context api를 사용해서 관리한다.)

  - 유저 상태 관리하기 
   → 유저가 로그인했는 지를 관리하기 위해서 user라는 변수를 
     선언하고 false로 할당한다. 
     로그인할 경우 true로 설정해서 유저가 로그인했다는 것을
     표시하여 유저 상태를 관리할 거다. 

   → 유저가 로그인하면 접근하지 않도록 설정할 페이지 
    ◎ 로그인 페이지, 회원가입 페이지 
     => 로그인하지 않았다면 각각 로그인, 회원가입 페이지로
        이동하고, 로그인했다면 home 페이지로 이동

    ◎ write, setting 페이지
     => 로그인하지 않았다면 write, setting 페이지에 
        접근하지 않고 로그인 페이지로 이동

10) React Context API 사용하기(React Context API Best Practise)
 - context 폴더 생성하고, context.js, action.js, 
   reducer.js 파일을 생성한다. 

 - context.js 파일에 초기 상태, context 생성,
   action, reducer 함수를 정의한다. 

 - useReducer로 복잡한 상태 관리를 할 수 있다. 
    
11) 로그인 구현(React Node.js Login System)
 - try ~ catch문을 사용해서 로직을 작성한다.
 - 로그인 버튼을 누르면 비동기 처리로 username,
   userpassword를 담은 객체를 서버에 전달해준다. 
  → 사용자의 입력한 input(실제 DOM)에 직접 접근(useRef)해서
    username, password 값을 받아서 서버측에 전달해준다. 
 - 서버측에서 응답된 결과값(res.data)과 type을 dispatch 
   함수의 인자에 넣어서 전달해준다. 전달된 인자는 reducer 
   함수에서 action 매개변수로 받는다. 

12) Context API과 로컬스토리지 사용하기(Using Local Storage with Context API)
 - 로그인할 때 서버측에서 전달받은 user 데이터를 
   context, 로컬스토리지에 담아서 관리한다. 

 - 나중에 로그인 및 로그아웃 상태를 구현할 때 사용된다.

13) Context API과 현재 유저 상태 사용하는법(How to use current user with Context API)
 - context에 저장된 유저 상태로 활용하여 
   로그인 상태를 표시한다. 

14) Context API를 사용한 로그아웃 구현(React Logout using Context API)
 - logout의 type, logout에 대한 action을 생성한 다음 
   reducer 함수에 추가해준다. 

 - 로그아웃에 대한 로직은 topBar 컴포넌트에서 구현한다. 
  → dispatch 함수를 호출해서 인자로 type: 'LOGOUT'을 전달한다.   

15) Axios를 사용한 새 Post 생성하기(Creating new post using Axios)
 - write 컴포넌트에서 axios를 사용해서 새 post를 생성하기
  → post의 title, desc를 객체에 담아 전달
  → context에 담은 username도 같이 전송

16) 리액트로 서버에 파일 업로드하기(React upload file to the Node.js server)

 포스트 업로드 폼 구현하기 
 (포스트 배경 업로드, 이미지 미리보기) 
 - input[type=file]로 이미지 파일을 추가하면, 이미지는 
   formData api를 사용해서 전달
  → 이미지와 같은 데이터를 전달하기 위해 formData 객체 생성,
    data 변수(인스턴스, formData 객체)에 담기 
 - filename은 같은 이름으로 업로드할 수 있으므로 
   날짜 + filename으로 한다. 
 - 생성된 data(formData의 인스턴스) 객체에 filename, file을 
   추가(append)한다
 - axios를 사용해서 /upload 로 data 객체를 전달 

 (포스트폼 기능 완성하기)
 - input[type=file]로 이미지 파일을 불러오면 불러온 이미지를 
   배경 부분에 미리보여주도록 한다.(이미지 미리보기)
  → input[type=file]로 이미지 파일을 불러오면 상태로 관리해준다.
   ◎ setFile(e.target.files[0]);

  → 파일을 불러오면 이미지 배경을 미리보기 해준다. 
   ◎ {file && (
        <img 
          className="writeImg" 
          src={URL.createObjectURL(file)} 
          alt="" 
        />
     )}

 - 성공적으로 포스트폼을 전달하면 업로드된 포스트로 이동 
  ◎ window.location.replace(`/post/${res.data._id}`);

 - post 컴포넌트에서 서버에 업로드한 이미지url를 img의 src 속성에
   넣는다. 

 - 경로 설정을 위해 서버측에 path 라이브러리를 설치한다. 
  ◎ npm i path 또는 yarn add path   
 
 - 정적 이미지 라우팅 처리하기
  → 나중에 게시글 배경을 받아오기 위함

 - 서버측의 이미지 업로드 처리부분을 완료했다면 
   프론트측(리액트, post컴포넌트, singlePost 컴포넌트)에서 
   이미지 업로드되 서버 url를 통해 이미지 리소스를 불러온다. 
   즉, 서버측에 라우팅된 이미지 url를 이미지 속성의 src부분에 
   적어주면 된다.
   

17) Post 삭제 기능 구현(React delete post)
 - 로그인하지 않거나 자신의 게시물이 아닌 경우 수정 
   버튼을 비활성화한다. 
  <h1 className="singlePostTitle">
    {post && post.username === users?.username && (
      <div className="singlePostEdit">
        <i className="singlePostIcon far fa-edit"></i>
        <i className="singlePostIcon far fa-trash-alt"></i>
      </div>
    )}
  </h1> 

  - username은 useContext으로 불러온다.  
  - 사용자가 없으면 보지 않도록 설정 
   → users?.username 는 users 객체가 undefined이면 
     아무것도 보이지 않고 users 객체가 존재하면 
     username 속성이 들어있으므로 username을 
     post.username 비교해서 수정 버튼이 보이도록 설정
  - post.name과 req.body.username(전달받는 username) 비교
   → 서버측에 프론트측에서 전달한 username과 비교해서 맞다면 
     해당 유저의 게시물을 삭제한다. 
   ❗ 사실 유저의 게시물을 완전히(디비에서 삭제) 삭제하는 것은 
     좋지 않으므로 삭제했다는 표시만 하도록 나중에 수정하기 
     (제로초 강의를 보면 이해가능)     

18) Post 수정기능 구현(React update post)
  - title, desc 를 전달받아서 게시글을 수정하는 로직 작성하기
   → 수정 버튼을 클릭하면 수정 모드로 변환하기 
  
  - updateMode 로 수정 모드 구현하기 
   → updateMode가 true인 경우 수정 모드 활성화하기 
   → input, textarea에 스타일 주기 

  - 수정 로직은 삭제 로직과 비슷하다. 
   → 여기서 http 메서드를 put으로 해주고 title, desc를
     추가 넣어주면된다. 
     즉, 수정될 사항들을 전달해주면 됨 

   → updateMode에 따라서 수정 모드를 활성, 비활성해주면
     된다. 코드가 길어진다면 함수화하는 작업을 해도 좋을
     것 같다.

19) Context API를 사용해서 유저 정보 수정 기능 구현
    (Updating user using Context API)
  - 사용자 설정 페이지(= 프로필)에서 유저 정보 
    수정 기능 구현하기 
   → 프로필 이미지를 클릭하기 때문에 커서 포인터로 
     스타일링하기 

  - write 컴포넌트에서 작성한 handleSubmit 부분을
    복사해서 사용한다. 
   → 유저 정보를 수정할 데이터들을 서버측에 전달
     해주면 된다. 
   → 수정하는 데 필요한 데이터는 userId, password
     및 유저 스키마에 정의한 속성 그대로 전달해주면 된다.
   → userId와 password는 유저 정보가 일치하는지를 
     서버측에서 비교해서 디비에서 조회하기 위함
   → profilePic는 write에서 배경 이미지를 업로드하는 
     부분과 비슷하다.     
            


20) 마무리(Outro)
 [해결할 부분 ]
  (dev)
  - 프로젝트 실행할 때, 프론트 + 백엔드 같이 실행되도록 설정

  (기능)
  - 로그아웃할 때, 새로고침하면 여전히 로그인 상태 수정하기
  - 로그아웃 기능 다시 만들기, 원래는 토큰을 디비에서 지우도록
    요청해야함
  - 프로필 정보 수정하면 수정되기전 데이터가 그대로 남아있음
    서버측 디비에는 잘 들어왔지만 프론트측에서 context를 
    수정해야할 것 같다.

 💡 그냥 유저 부분(로그인 부분)부터 다시 해야할 것같다. 
    → post 및 카테고리는 상관없음 
    → 강사의 완성본을 보며 나만의 방식으로 수정하기

❗ yarn 으로 패키지를 설치 중 아래와 같은 에러 해결하기
  error recursive-iterator@2.0.1
   : The engine "node" is incompatible with this module. ~ 이하 생략
  error Found incompatible module
  → 현재 node 버전과 호환되지 않아서 이러한 에러가 발생했다. 
    최신(LTS) 버전으로 설치해주면 해결된다. 